import Mathlib.Data.List.Basic
import Mathlib.Data.List.Nodup
import Mathlib.Logic.Relation
import Batteries.Data.Vector.Lemmas

import Wavelet.Compile.Fn.Defs
import Wavelet.Compile.Fn.Simulation.Invariants
import Wavelet.Compile.Fn.Lemmas

/-! Lemmas to fire the chain of merges generated for nested branches. -/

namespace Wavelet.Compile.Fn

open Semantics Seq Dataflow Compile Fn

/-- Intermediate channel maps after the `forwardc` and `sink`
have fired, but before the `merge`s finish. -/
def intermChans
  [InterpConsts V] [DecidableEq χ]
  m n
  (gs : GhostState χ)
  (clearVars : Vector χ k)
  (vals : Vector V (n + (m + 1)))
  (pathConds : List (Bool × ChanName χ))
  (name : ChanName χ)
  : List V :=
  match (compileExpr.exprOutputs m n pathConds).finIdxOf? name with
  | some i => [vals[i]]
  | x =>
    if name ∈ clearVars.map (.var · gs.pathConds) then
      []
    else
      -- `merge_cond` channels outside `pathConds` should be empty
      match name with
      | .merge_cond condName =>
        if (true, condName) ∈ pathConds then
          [InterpConsts.fromBool true]
        else if (false, condName) ∈ pathConds then
          [InterpConsts.fromBool false]
        else []
      | _ => []

/-- Descibes the effect of the `merge`s generated by all excuted conditionals. -/
theorem sim_step_merges
  [Arity Op] [InterpConsts V] [DecidableEq χ]
  {l : Label Op V m n}
  (pc : Dataflow.Config Op (ChanName χ) V m n)
  (gs : GhostState χ)
  (hmerges : HasMerges m n pc.proc.atoms pathConds)
  (hpath_conds : pathConds.Sublist gs.pathConds)
  (hpath_conds_nodup : (gs.pathConds.map Prod.snd).Nodup)
  (hsteps :
    Dataflow.Config.Step.WeakStep .τ pc l
    { proc := pc.proc,
      chans := intermChans m n gs vars outputVals pathConds })
  : Dataflow.Config.Step.WeakStep .τ pc l
    { proc := pc.proc,
      chans := intermChans m n gs vars outputVals [] }
  := by
  induction pathConds with
  | nil => exact hsteps
  | cons headCond tailConds ih =>
    rcases headCond with ⟨condBool, condName⟩
    simp only [HasMerges] at hmerges
    have ⟨hhead_merge, hmerges_rest⟩ := hmerges
    simp [compileExpr.branchMerge] at hhead_merge
    -- Pop the current merge condition
    have hmem_cond_path_conds : (condBool, condName) ∈ gs.pathConds :=
      List.Sublist.mem (by simp) hpath_conds
    have hnot_mem_cond_tail_conds {b} : (b, condName) ∉ tailConds :=
      path_conds_nodup_alt hpath_conds_nodup hpath_conds
    have ⟨chans₁, hpop_cond, hchans₁⟩ := pop_val_singleton
      (map := intermChans m n gs vars
        outputVals
        ((condBool, condName) :: tailConds))
      (name := .merge_cond condName)
      (val := InterpConsts.fromBool condBool)
      (by
        simp [intermChans]
        if h : condBool = true then
          simp [h] at hmem_cond_path_conds ⊢
        else
          simp [h] at hmem_cond_path_conds ⊢
          intros h
          simp [hnot_mem_cond_tail_conds] at h)
    -- Pop `compileExpr.exprOutputs`
    have ⟨chans₂, outputVals', hpop_output_vals, hchans₂, houtput_vals⟩ :=
      pop_vals_singleton
      (map := chans₁)
      (names := compileExpr.exprOutputs m n ((condBool, condName) :: tailConds))
      (λ name val =>
        match name with
        | .dest i _ => ∃ (h : i < n), val = outputVals[i]
        | .tail_arg i _ => ∃ (h : i < m), val = outputVals[n + i]
        | .tail_cond _ => val = outputVals[n + m]
        | _ => False)
      (by apply exprOutputs_nodup)
      (by
        intros name hname
        simp [hchans₁, intermChans]
        simp [compileExpr.exprOutputs] at hname
        rcases hname with ⟨_, h₁, hname⟩ | ⟨_, h₁, hname⟩ | hname
        · simp [← hname, exprOutputs_finIdxOf?_dest h₁, h₁]
        · simp [← hname, exprOutputs_finIdxOf?_tail_args h₁, h₁]
        · simp [hname, exprOutputs_finIdxOf?_tail_cond])
    have : outputVals = outputVals' := by
      symm
      apply Vector.toList_inj.mp
      apply List.right_unique_forall₂' _ houtput_vals
      · simp [compileExpr.exprOutputs, Vector.toList_append,
          Vector.toList_push, Vector.toList_map, Vector.toList_range]
        apply List.forall₂_iff_get.mpr
        constructor
        · simp
        · intros i hi₁ hi₂
          simp [List.getElem_append]
          split_ifs <;> rename_i hi₃
          · simp [hi₃]
          · simp [hi₃]
            congr 1
            omega
          · simp at ⊢ hi₂
            congr 1
            omega
      · simp [Relator.RightUnique]
        intros a b c hb hc
        split at hb <;> simp at hc
        · replace ⟨_, hb⟩ := hb
          replace ⟨_, hc⟩ := hc
          simp [hc, hb]
        · replace ⟨_, hb⟩ := hb
          replace ⟨_, hc⟩ := hc
          simp [hc, hb]
        · simp [hc, hb]
    subst this
    -- Fire `merge`
    -- Some manipulation to match the preconditions of `step_merge`
    have :
      compileExpr.exprOutputs m n ((condBool, condName) :: tailConds)
      = if condBool = true then
          compileExpr.exprOutputs m n ((true, condName) :: tailConds)
        else
          compileExpr.exprOutputs m n ((false, condName) :: tailConds)
    := by split <;> (rename_i h; simp [h])
    simp only [this] at hpop_output_vals
    replace hsteps : Dataflow.Config.Step.WeakStep .τ pc l _
      := .tail_tau_star hsteps (Dataflow.Config.Step.step_merge
        hhead_merge
        hpop_cond
        (InterpConsts.unique_fromBool_toBool _)
        hpop_output_vals)
    -- Simplify pushes
    rw [push_vals_empty] at hsteps
    rotate_left
    · apply exprOutputs_nodup
    · intros name hname
      -- simp [compileExpr.exprOutputs] at hname
      simp [hchans₂, hchans₁, intermChans]
      intros h₁ h₂
      split <;> rename_i h₃
      · have := Vector.finIdxOf?_eq_none_iff.mpr h₁
        simp only [compileExpr.exprOutputs] at this
        simp [compileExpr.exprOutputs, this] at h₃
      · simp
        intros h₄
        split <;> rename_i h₅
        · simp [compileExpr.exprOutputs] at hname
        · rfl
    exact ih hmerges_rest
      (List.sublist_of_cons_sublist hpath_conds)
      (hsteps.eq_rhs (by
        -- Some simplification to satisfy IH
        simp
        funext name
        simp [intermChans, compileExpr.exprOutputs, compileExpr.exprOutputs]
        split <;> rename_i h₁
        · rename_i i
          simp [h₁]
        · replace h₁ := Option.eq_none_iff_forall_ne_some.mpr h₁
          -- have h₁' := Vector.finIdxOf?_eq_none_iff.mp h₁
          simp [h₁]
          simp [hchans₂]
          simp only [compileExpr.exprOutputs]
          split <;> rename_i h₂
          · simp at h₂
            simp
            rcases h₂ with ⟨_, _, h₂⟩ | ⟨_, _, h₂⟩ | h₂
            · simp [← h₂]
            · simp [← h₂]
            · simp [h₂]
          · simp [hchans₁]
            split <;> rename_i h₃
            · simp [h₃, hnot_mem_cond_tail_conds]
            · simp [intermChans, compileExpr.exprOutputs,
                Vector.finIdxOf?_eq_none_iff.mpr h₂]
              split <;> rename_i h₄
              · rfl
              · split <;> rename_i chanName'
                · grind
                · rfl))

end Wavelet.Compile.Fn
