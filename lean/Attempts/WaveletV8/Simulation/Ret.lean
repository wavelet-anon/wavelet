import Mathlib.Data.Vector.Basic

import Wavelet.Op
import Wavelet.LTS
import Wavelet.Seq
import Wavelet.Dataflow
import Wavelet.Compile
import Wavelet.Lemmas

import Wavelet.Simulation.Invariants
import Wavelet.Simulation.Lemmas

/-! Simulation in the case of return. -/

namespace Wavelet.Simulation.Ret

open Wavelet.Op Wavelet.LTS Wavelet.Seq Wavelet.Dataflow Wavelet.Compile
open Invariants Lemmas

/-- Values pushed to output channels in the case of a return. -/
def retValsToExprOutputs
  [InterpConsts V]
  (retVals : Vector V n) : Vector V (n + (m + 1)) :=
  retVals ++
  (Vector.replicate m (InterpConsts.junkVal : V)).push
  (InterpConsts.fromBool false)

/-- Intermediate channel maps after the `forwardc` and `sink`
have fired, but before the `merge`s finish. -/
def intermChans
  [Arity Op] [InterpConsts V] [DecidableEq χ]
  (ec : Seq.Config Op χ V S m n)
  (_pc : Dataflow.Config Op (ChanName χ) V S m n)
  (clearVars : Vector χ k)
  (vals : Vector V (n + (m + 1)))
  (pathConds : List (Bool × ChanName χ))
  (name : ChanName χ)
  : List V :=
  match (compileExpr.exprOutputs m n pathConds).finIdxOf? name with
  | some i => [vals[i]]
  | x =>
    if name ∈ clearVars.map (.var · ec.pathConds) then
      []
    else
      -- `merge_cond` channels outside `pathConds` should be empty
      match name with
      | .merge_cond condName =>
        if (true, condName) ∈ pathConds then
          [InterpConsts.fromBool true]
        else if (false, condName) ∈ pathConds then
          [InterpConsts.fromBool false]
        else []
      | _ => []

/-- Descibes the effect of the `merge`s generated by all excuted conditionals. -/
theorem sim_step_merges
  [Arity Op] [InterpConsts V] [InterpOp Op V E S] [DecidableEq χ]
  {tr : Trace E}
  (ec : Seq.Config Op χ V S m n)
  (pc : Dataflow.Config Op (ChanName χ) V S m n)
  (hmerges : HasMerges m n pc.proc.atoms pathConds)
  (hpath_conds : pathConds.Sublist ec.pathConds)
  (hpath_conds_nodup : (ec.pathConds.map Prod.snd).Nodup)
  (hsteps :
    Dataflow.Config.StepPlus pc tr
    { proc := pc.proc,
      chans := intermChans ec pc vars outputVals pathConds
      state := pc.state })
  : Dataflow.Config.StepPlus pc tr
    { proc := pc.proc,
      chans := intermChans ec pc vars outputVals []
      state := pc.state }
  := by
  induction pathConds with
  | nil => exact hsteps
  | cons headCond tailConds ih =>
    rcases headCond with ⟨condBool, condName⟩
    simp only [HasMerges] at hmerges
    have ⟨hhead_merge, hmerges_rest⟩ := hmerges
    simp [compileExpr.branchMerge] at hhead_merge
    -- Pop the current merge condition
    have hmem_cond_path_conds : (condBool, condName) ∈ ec.pathConds :=
      List.Sublist.mem (by simp) hpath_conds
    have hnot_mem_cond_tail_conds {b} : (b, condName) ∉ tailConds :=
      path_conds_nodup_alt hpath_conds_nodup hpath_conds
    have ⟨chans₁, hpop_cond, hchans₁⟩ := pop_val_singleton _ _
      (map := intermChans ec pc vars
        outputVals
        ((condBool, condName) :: tailConds))
      (name := .merge_cond condName)
      (val := InterpConsts.fromBool condBool)
      (by
        simp [intermChans]
        if h : condBool = true then
          simp [h] at hmem_cond_path_conds ⊢
        else
          simp [h] at hmem_cond_path_conds ⊢
          intros h
          simp [hnot_mem_cond_tail_conds] at h)
    -- Pop `compileExpr.exprOutputs`
    have ⟨chans₂, outputVals', hpop_output_vals, hchans₂, houtput_vals⟩ :=
      pop_vals_singleton _ _
      (map := chans₁)
      (names := compileExpr.exprOutputs m n ((condBool, condName) :: tailConds))
      (λ name val =>
        match name with
        | .dest i _ => ∃ (h : i < n), val = outputVals[i]
        | .tail_arg i _ => ∃ (h : i < m), val = outputVals[n + i]
        | .tail_cond _ => val = outputVals[n + m]
        | _ => False)
      (by apply exprOutputs_nodup)
      (by
        intros name hname
        simp [hchans₁, intermChans]
        simp [compileExpr.exprOutputs] at hname
        rcases hname with ⟨_, h₁, hname⟩ | ⟨_, h₁, hname⟩ | hname
        · simp [← hname, exprOutputs_finIdxOf?_dest h₁, h₁]
        · simp [← hname, exprOutputs_finIdxOf?_tail_args h₁, h₁]
        · simp [hname, exprOutputs_finIdxOf?_tail_cond])
    have : outputVals = outputVals' := by
      symm
      apply Vector.toList_inj.mp
      apply List.right_unique_forall₂' _ houtput_vals
      · simp [compileExpr.exprOutputs, Vector.toList_append,
          Vector.toList_push, Vector.toList_map, Vector.toList_range]
        apply List.forall₂_iff_get.mpr
        constructor
        · simp
        · intros i hi₁ hi₂
          simp [List.getElem_append]
          split_ifs <;> rename_i hi₃
          · simp [hi₃]
          · simp [hi₃]
            congr 1
            omega
          · simp at ⊢ hi₂
            congr 1
            omega
      · simp [Relator.RightUnique]
        intros a b c hb hc
        split at hb <;> simp at hc
        · replace ⟨_, hb⟩ := hb
          replace ⟨_, hc⟩ := hc
          simp [hc, hb]
        · replace ⟨_, hb⟩ := hb
          replace ⟨_, hc⟩ := hc
          simp [hc, hb]
        · simp [hc, hb]
    subst this
    -- Fire `merge`
    -- Some manipulation to match the preconditions of `step_merge`
    have :
      compileExpr.exprOutputs m n ((condBool, condName) :: tailConds)
      = if condBool = true then
          compileExpr.exprOutputs m n ((true, condName) :: tailConds)
        else
          compileExpr.exprOutputs m n ((false, condName) :: tailConds)
    := by split <;> (rename_i h; simp [h])
    simp only [this] at hpop_output_vals
    have hstep : Dataflow.Config.Step (E := E)
      { proc := pc.proc,
        chans := intermChans ec pc vars
          outputVals
          ((condBool, condName) :: tailConds)
        state := pc.state } _ _
      := Dataflow.Config.Step.step_merge
        hhead_merge
        hpop_cond
        (InterpConsts.unique_fromBool_toBool _)
        hpop_output_vals
    -- Simplify pushes
    rw [push_vals_empty] at hstep
    rotate_left
    · apply exprOutputs_nodup
    · intros name hname
      -- simp [compileExpr.exprOutputs] at hname
      simp [hchans₂, hchans₁, intermChans]
      intros h₁ h₂
      split <;> rename_i h₃
      · have := Vector.finIdxOf?_eq_none_iff.mpr h₁
        simp only [compileExpr.exprOutputs] at this
        simp [compileExpr.exprOutputs, this] at h₃
      · simp
        intros h₄
        split <;> rename_i h₅
        · simp [compileExpr.exprOutputs] at hname
        · rfl
    -- Connect `hsteps` and `hstep`
    replace hsteps := LTS.Plus.tail hsteps hstep
    exact ih hmerges_rest
      (List.sublist_of_cons_sublist hpath_conds)
      (LTS.step_eq_tr_rhs hsteps (by simp) (by
        -- Some simplification to satisfy IH
        simp
        funext name
        simp [intermChans, compileExpr.exprOutputs, compileExpr.exprOutputs]
        split <;> rename_i h₁
        · rename_i i
          simp [h₁]
        · replace h₁ := Option.eq_none_iff_forall_ne_some.mpr h₁
          -- have h₁' := Vector.finIdxOf?_eq_none_iff.mp h₁
          simp [h₁]
          simp [hchans₂]
          simp only [compileExpr.exprOutputs]
          split <;> rename_i h₂
          · simp at h₂
            simp
            rcases h₂ with ⟨_, _, h₂⟩ | ⟨_, _, h₂⟩ | h₂
            · simp [← h₂]
            · simp [← h₂]
            · simp [h₂]
          · simp [hchans₁]
            split <;> rename_i h₃
            · simp [h₃, hnot_mem_cond_tail_conds]
            · simp [intermChans, compileExpr.exprOutputs,
                Vector.finIdxOf?_eq_none_iff.mpr h₂]
              split <;> rename_i h₄
              · rfl
              · split <;> rename_i chanName'
                · grind
                · rfl))

/-- Fires `forwardc` and `sink` to get an intermediate state. -/
theorem sim_step_ret_forwardc_sink
  [Arity Op] [InterpConsts V] [InterpOp Op V E S] [DecidableEq χ]
  {ec : Seq.Config Op χ V S m n}
  {pc : Dataflow.Config Op (ChanName χ) V S m n}
  {hnz : m > 0 ∧ n > 0}
  (hsim : SimRel hnz ec pc)
  (hexpr : ec.expr = .cont (.ret vars))
  (hvars : VarMap.getVars vars ec.vars = some retVals)
  (hvars_nodup : vars.toList.Nodup) :
  Dataflow.Config.StepPlus (E := E) pc .ε
  { proc := pc.proc,
    chans := intermChans ec pc vars
      (retValsToExprOutputs retVals)
      ec.pathConds
    state := pc.state }
:= by
  have ⟨
    rest, carryInLoop, ctxLeft, ctxCurrent, ctxRight,
    hatoms, hcomp_fn, hrest, hret, hcont,
  ⟩ := hsim.has_compiled_procs
  have ⟨hcarryInLoop, hwf_expr, hcurrent⟩ := hcont _ hexpr
  simp [compileExpr] at hcurrent
  -- Step 1: Fire `forwardc`.
  have ⟨chans₁, retVals', hpop_ret_vals, hchans₁, hret_vals⟩ :=
    pop_vals_singleton _ _
    (map := pc.chans)
    (names := vars.map (.var · ec.pathConds))
    (λ name val =>
      ∃ var,
        name = .var var ec.pathConds ∧
        ec.vars.getVar var = some val)
    (by
      simp only [Vector.toList_map]
      apply List.Nodup.map _ hvars_nodup
      simp [Function.Injective])
    (by
      simp [hsim.vars_to_chans, varsToChans]
      have := Vector.mapM_some_implies_all_some hvars
      intros v hmem_v
      have ⟨val, _, hval⟩ := this v hmem_v
      exists val
      simp [VarMap.getVar, hval])
  have heq_ret_vals :
    retVals' = retVals
  := by
    apply Vector.toList_inj.mp
    apply List.right_unique_forall₂' _ hret_vals
    · simp [Vector.toList_map, VarMap.getVar]
      apply List.mapM_some_iff_forall₂.mp (Vector.mapM_toList hvars)
    · simp [Relator.RightUnique, VarMap.getVar]
      grind
  replace heq_ret_vals := heq_ret_vals.symm
  subst heq_ret_vals
  have hmem_forwardc :
    AtomicProc.forwardc
      (vars.map (.var · ec.pathConds))
      ((Vector.replicate m InterpConsts.junkVal).push
        (InterpConsts.fromBool false))
      (compileExpr.exprOutputs m n ec.pathConds)
      ∈ pc.proc.atoms
  := by grind
  have hsteps₁ : Dataflow.Config.StepPlus (E := E) pc .ε _
    := .single (Dataflow.Config.Step.step_forwardc hmem_forwardc hpop_ret_vals)
  -- Simplify pushes
  rw [push_vals_empty] at hsteps₁
  rotate_left
  · apply exprOutputs_nodup
  · intros name hmem_name
    simp at hmem_name
    simp [hchans₁, hsim.vars_to_chans, varsToChans]
    simp [compileExpr.exprOutputs] at hmem_name
    rcases hmem_name with ⟨_, _, h⟩ | ⟨_, _, h⟩ | h
    · simp [← h]
    · simp [← h]
    · simp [h]
  simp only [hchans₁] at hsteps₁
  replace ⟨pc₁, hpc₁, hsteps₁⟩ := exists_eq_left.mpr hsteps₁
  -- Step 2: Fire `sink` to consume all unused channels in the current context.
  have ⟨chans₂, otherVals, hpop_other_vals, hchans₂, hother_vals⟩ :=
    pop_vals_singleton _ _
    (map := pc₁.chans)
    (names := compileExpr.allVarsExcept ec.definedVars vars.toList ec.pathConds)
    (λ name val => True)
    (allVarsExcept_nodup hsim.defined_vars_nodup)
    (by
      simp
      intros name hname
      have ⟨var, hvar, hmem_var, hnot_mem_var⟩ := mem_allVarsExcept hname
      simp [hvar, hpc₁]
      simp [hsim.vars_to_chans, varsToChans]
      have ⟨val, h⟩ := hsim.defined_vars_to_get_var hmem_var
      exists val
      simp at hnot_mem_var
      simp [h, hnot_mem_var])
  have hmem_sink :
    .sink (compileExpr.allVarsExcept ec.definedVars vars.toList ec.pathConds)
    ∈ pc₁.proc.atoms
  := by grind
  have hsteps₂ : Dataflow.Config.StepPlus (E := E) pc .ε _
    := .tail hsteps₁
      (Dataflow.Config.Step.step_sink hmem_sink hpop_other_vals)
  apply LTS.step_eq_rhs
  apply hsteps₂
  simp [hpc₁]
  -- Prove that the final chan maps match
  funext name
  simp [intermChans, hchans₂, hpc₁]
  split <;> rename_i h₁
  · have ⟨var, hvar, hmem_var, hnot_mem_var⟩ := mem_allVarsExcept h₁
    simp [hvar]
  · split <;> rename_i h₂
    · simp [h₂, retValsToExprOutputs]
    · have := Option.eq_none_iff_forall_ne_some.mpr h₂
      simp [this]
      split <;> rename_i h₃
      · rfl
      · simp [hsim.vars_to_chans, varsToChans]
        cases name with
        | var var' pathConds' =>
          simp
          intros h
          simp [h] at h₃
          simp [compileExpr.allVarsExcept, List.toVector] at h₁
          split <;> rename_i h₄
          · replace h₄ := hsim.get_var_to_defined_vars ⟨_, h₄⟩
            have := h₁ (List.mem_to_mem_removeAll h₄ (by simp [h₃]))
            simp [h] at this
          · rfl
        | merge_cond condName => rfl
        | _ => simp [hexpr]

/-- Fires relevant operators on the dataflow side. -/
theorem sim_step_ret_exec_dataflow
  [Arity Op] [InterpConsts V] [InterpOp Op V E S] [DecidableEq χ]
  {rest}
  {tr : Trace E}
  {ec ec' : Seq.Config Op χ V S m n}
  {pc : Dataflow.Config Op (ChanName χ) V S m n}
  {hnz : m > 0 ∧ n > 0}
  (hsim : SimRel hnz ec pc)
  (hstep : Config.Step ec tr ec')
  (hexpr : ec.expr = .cont (.ret vars))
  (hpc_atoms : pc.proc.atoms = compileFn.initCarry ec.fn true :: rest) :
  Dataflow.Config.StepPlus pc tr {
    proc := {
      inputs := pc.proc.inputs,
      outputs := pc.proc.outputs,
      atoms := compileFn.initCarry ec.fn false :: rest
    },
    chans := varsToChans ec',
    state := pc.state,
  }
:= by
  have ⟨
    rest', carryInLoop, ctxLeft, ctxCurrent, ctxRight,
    hatoms, hcomp_fn, hrest, hret, hcont,
  ⟩ := hsim.has_compiled_procs
  have ⟨hcarryInLoop, hwf_expr, hcurrent⟩ := hcont _ hexpr
  have : rest = rest' := by
    simp [hatoms] at hpc_atoms
    exact hpc_atoms.2.symm
  subst this
  cases hstep with
  | step_br hexpr' | step_tail hexpr'
  | step_op_trans hexpr' | step_op_final hexpr' =>
    simp [hexpr] at hexpr'
  | step_ret hexpr' hvars =>
  rename_i retVals vars'
  simp [hexpr] at hexpr'
  subst hexpr'
  cases hwf_expr with | wf_ret hvars_nodup =>
  have hsteps₁ :=
    sim_step_ret_forwardc_sink (E := E) hsim hexpr hvars hvars_nodup
  have hsteps₂ := sim_step_merges ec pc
    hsim.has_merges (by simp)
    hsim.path_conds_nodup hsteps₁
  -- Step 4: Fire the `fork` in `compileFn`.
  simp only [compileFn, compileFn.resultSteers] at hcomp_fn
  have ⟨chans₁, hpop_tail_cond, hchans₁⟩ := pop_val_singleton _ _
    (map := intermChans ec pc vars
      (retValsToExprOutputs retVals)
      [])
    (name := .tail_cond [])
    (val := InterpConsts.fromBool false)
    (by simp [intermChans, exprOutputs_finIdxOf?_tail_cond, retValsToExprOutputs])
  have hmem_fork :
    .fork (ChanName.tail_cond [])
      #v[.tail_cond_carry, .tail_cond_steer_dests, .tail_cond_steer_tail_args]
    ∈ pc.proc.atoms
  := by grind
  have hsteps₃ : Dataflow.Config.StepPlus (E := E) pc _ _
    := .tail hsteps₂
      (Dataflow.Config.Step.step_fork hmem_fork hpop_tail_cond)
  -- Simplify pushes
  rw [push_vals_empty] at hsteps₃
  rotate_left
  · simp
  · simp [hchans₁, intermChans]
  simp at hsteps₃
  replace ⟨pc₁, hpc₁, hsteps₃⟩ := exists_eq_left.mpr hsteps₃
  -- Step 5: Fire the first `steer` in `compileFn` for return values.
  have ⟨chans₂, hpop_tail_cond_steer_dests, hchans₂⟩ := pop_val_singleton _ _
    (map := pc₁.chans)
    (name := .tail_cond_steer_dests)
    (val := InterpConsts.fromBool false)
    (by simp [hpc₁, List.finIdxOf?, List.findFinIdx?, List.findFinIdx?.go])
  have ⟨chans₃, destVals, hpop_dest_vals, hchans₃, hdest_vals⟩ :=
    pop_vals_singleton _ _
    (map := chans₂)
    (names := (Vector.range n).map (.dest · []))
    (λ name val =>
      match name with
      | .dest i _ => ∃ (h : i < n), val = retVals[i]
      | _ => False)
    (by
      simp [Vector.toList_map, Vector.toList_range]
      apply List.Nodup.map _ List.nodup_range
      simp [Function.Injective])
    (by
      intros name hname
      simp at hname
      replace ⟨i, h₂, hname⟩ := hname
      simp [← hname, hchans₂, hpc₁, hchans₁, intermChans,
        List.finIdxOf?, List.findFinIdx?, List.findFinIdx?.go,
        exprOutputs_finIdxOf?_dest h₂, h₂, retValsToExprOutputs])
  replace hdest_vals : destVals = retVals := by
    apply Vector.toList_inj.mp
    apply List.right_unique_forall₂' _ hdest_vals
    · apply List.forall₂_iff_get.mpr
      simp [Vector.toList_map, Vector.toList_range]
    · simp [Relator.RightUnique]
      intros a b c hb hc
      split at hb <;> simp at hc
      replace ⟨_, hb⟩ := hb
      replace ⟨_, hc⟩ := hc
      simp [hc, hb]
  subst hdest_vals
  have hmem_steer_dests :
    .steer false
      .tail_cond_steer_dests
      ((Vector.range n).map (.dest · []))
      ((Vector.range n).map .final_dest)
    ∈ pc₁.proc.atoms
  := by grind
  have hsteps₄ : Dataflow.Config.StepPlus (E := E) pc _ _
    := .tail hsteps₃
      (Dataflow.Config.Step.step_steer
        hmem_steer_dests
        hpop_tail_cond_steer_dests
        hpop_dest_vals
        (InterpConsts.unique_fromBool_toBool _))
  -- Simplify pushes
  rw [push_vals_empty] at hsteps₄
  rotate_left
  · simp [Vector.toList_map, Vector.toList_range]
    apply List.Nodup.map _ List.nodup_range
    simp [Function.Injective]
  · simp [hchans₃, hchans₂, hpc₁,
      List.finIdxOf?, List.findFinIdx?, List.findFinIdx?.go,
      hchans₁, intermChans]
  simp at hsteps₄
  replace ⟨pc₂, hpc₂, hsteps₄⟩ := exists_eq_left.mpr hsteps₄
  -- Step 6: Fire the second `steer` in `compileFn` for tail call args.
  have ⟨chans₄, hpop_tail_cond_steer_tail_args, hchans₄⟩ := pop_val_singleton _ _
    (map := pc₂.chans)
    (name := .tail_cond_steer_tail_args)
    (val := InterpConsts.fromBool false)
    (by
      simp [hpc₂, hchans₃, hchans₂, hpc₁,
        List.finIdxOf?, List.findFinIdx?, List.findFinIdx?.go])
  have ⟨chans₅, tailArgVals, hpop_tail_arg_vals, hchans₅, htail_arg_vals⟩ :=
    pop_vals_singleton _ _
    (map := chans₄)
    (names := (Vector.range m).map (.tail_arg · []))
    (λ name val => True)
    (by
      simp [Vector.toList_map, Vector.toList_range]
      apply List.Nodup.map _ List.nodup_range
      simp [Function.Injective])
    (by
      simp
      intros i hi
      simp [hchans₄, hpc₂, hchans₃, hchans₂, hpc₁,
        List.finIdxOf?, List.findFinIdx?, List.findFinIdx?.go,
        hchans₁, intermChans,
        exprOutputs_finIdxOf?_tail_args hi])
  have hmem_steer_tail_args :
    .steer true
      .tail_cond_steer_tail_args
      ((Vector.range m).map (.tail_arg · []))
      ((Vector.range m).map .final_tail_arg)
    ∈ pc₂.proc.atoms
  := by grind
  have hsteps₅ : Dataflow.Config.StepPlus (E := E) pc _ _
    := .tail hsteps₄
      (Dataflow.Config.Step.step_steer
        hmem_steer_tail_args
        hpop_tail_cond_steer_tail_args
        hpop_tail_arg_vals
        (InterpConsts.unique_fromBool_toBool _))
  simp at hsteps₅
  replace ⟨pc₃, hpc₃, hsteps₅⟩ := exists_eq_left.mpr hsteps₅
  -- Step 7: Fire the first `carry` in `compileFn`.
  have ⟨chans₆, hpop_tail_cond_steer_tail_args, hchans₆⟩ := pop_val_singleton _ _
    (map := pc₃.chans)
    (name := .tail_cond_carry)
    (val := InterpConsts.fromBool false)
    (by
      simp [hpc₃, hchans₅, hchans₄, hpc₂, hchans₃, hchans₂, hpc₁,
        List.finIdxOf?, List.findFinIdx?, List.findFinIdx?.go])
  have hmem_carry :
    pc₃.proc.atoms = [] ++ [compileFn.initCarry ec.fn carryInLoop] ++ rest
  := by simp [hpc₃, hpc₂, hpc₁, hatoms]
  simp only [compileFn.initCarry, hcarryInLoop] at hmem_carry
  have hsteps₆ : Dataflow.Config.StepPlus (E := E) pc _ _
    := .tail hsteps₅
      (Dataflow.Config.Step.step_carry_false
        hmem_carry
        hpop_tail_cond_steer_tail_args
        (InterpConsts.unique_fromBool_toBool _))
  simp at hsteps₆
  replace ⟨pc', hpc', hsteps₆⟩ := exists_eq_left.mpr hsteps₆
  apply LTS.step_eq_rhs hsteps₆
  simp [hpc', hpc₃, hpc₂, hpc₁]
  constructor
  · simp [compileFn.initCarry]
  -- Prove that the final channel maps match
  · funext name
    simp [hpc₃, hchans₆, hchans₅, hchans₄, hpc₂, hchans₃,
      hchans₂, hpc₁, hchans₁,
      varsToChans, VarMap.empty, VarMap.getVar]
    cases name with
    | input | var | switch_cond | merge_cond | final_tail_arg =>
      simp [List.finIdxOf?, List.findFinIdx?, List.findFinIdx?.go,
        intermChans, compileExpr.exprOutputs]
      rw [Vector.finIdxOf?_eq_none_iff.mpr (by simp)]
    | dest | tail_arg =>
      simp [List.finIdxOf?, List.findFinIdx?, List.findFinIdx?.go, intermChans]
      intros h₁
      simp [
        exprOutputs_finIdxOf?_no_match_dest h₁,
        exprOutputs_finIdxOf?_no_match_tail_args h₁,
      ]
    | tail_cond =>
      simp [List.finIdxOf?, List.findFinIdx?, List.findFinIdx?.go, intermChans]
      intros h₁
      simp [exprOutputs_finIdxOf?_no_match_tail_cond h₁]
    | tail_cond_carry | tail_cond_steer_dests | tail_cond_steer_tail_args => simp
    | final_dest =>
      simp
      split_ifs <;> rename_i i h₁
      · rw [(Vector.finIdxOf?_eq_some_iff (i := ⟨i, h₁⟩)).mpr]
        simp [Fin.lt_def]
        omega
      · rw [Vector.finIdxOf?_eq_none_iff.mpr]
        · simp [List.finIdxOf?, List.findFinIdx?, List.findFinIdx?.go,
            intermChans, compileExpr.exprOutputs]
          rw [Vector.finIdxOf?_eq_none_iff.mpr (by simp)]
        · simp [h₁]

theorem sim_step_ret
  [Arity Op] [InterpConsts V] [InterpOp Op V E S] [DecidableEq χ]
  {tr : Trace E}
  {ec ec' : Seq.Config Op χ V S m n}
  {pc : Dataflow.Config Op (ChanName χ) V S m n}
  {hnz : m > 0 ∧ n > 0}
  (hsim : SimRel hnz ec pc)
  (hstep : Config.Step ec tr ec')
  (hexpr : ec.expr = .cont (.ret vars)) :
  ∃ pc',
    Config.StepPlus pc tr pc' ∧
    SimRel hnz ec' pc' := by
  have ⟨
    rest, carryInLoop, ctxLeft, ctxCurrent, ctxRight,
    hatoms, hcomp_fn, hrest, hret, hcont,
  ⟩ := hsim.has_compiled_procs
  have ⟨hcarryInLoop, hwf_expr, hcurrent⟩ := hcont _ hexpr
  simp [hcarryInLoop] at hatoms
  have hsteps := sim_step_ret_exec_dataflow hsim hstep hexpr hatoms
  replace ⟨pc', hpc', hsteps⟩ := exists_eq_left.mpr hsteps
  cases hstep with
  | step_br hexpr' | step_tail hexpr'
  | step_op_trans hexpr' | step_op_final hexpr' =>
    simp [hexpr] at hexpr'
  | step_ret hexpr' hvars =>
    rename_i retVals vars'
    simp [hexpr] at hexpr'
    subst hexpr'
    cases hwf_expr with | wf_ret hvars_nodup =>
    exists pc'
    constructor
    · exact hsteps
    · simp only [hpc']
      and_intros
      · simp only [hsim.eq_state]
      · simp
      · simp
      · simp [VarMap.empty, VarMap.getVar]
      · simp [OrderedPathConds]
      · simp
      · simp [HasMerges]
      · exact hsim.wf_fn.1
      · exact hsim.wf_fn.2
      · simp [compileFn.initCarry, HasCompiledProcs]
        exact hcomp_fn

end Wavelet.Simulation.Ret
